<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>排班OCR（多圖、相似姓名合併、CSV匯出）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
  body { font-family: system-ui, -apple-system, "Noto Sans TC", Arial; padding: 16px; line-height: 1.6; }
  h1 { font-size: 1.25rem; margin-bottom: 8px; }
  .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
  .btn { padding: 8px 12px; border-radius: 10px; border: 1px solid #ddd; background: #fafafa; cursor: pointer; }
  .btn:disabled { opacity: .5; cursor: not-allowed; }
  .preview { max-width: 140px; max-height: 140px; border-radius: 10px; border: 1px solid #eee; object-fit: contain; background:#fff; }
  .card { border:1px solid #eee; border-radius: 12px; padding: 12px; margin: 8px 0; background:#fff; }
  .muted { color:#666; font-size: .9em; }
  .mono { font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace; }
  table { width: 100%; border-collapse: collapse; font-size: .92em; }
  th, td { border-bottom: 1px solid #eee; padding: 6px 8px; vertical-align: top; }
  th { background:#fafafa; position: sticky; top: 0; z-index: 2; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 8px; }
  details summary { cursor: pointer; user-select: none; }
  .chip { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius: 999px; margin:2px; background:#f7f7f7; }
  .progress { height: 6px; background:#eee; border-radius: 999px; overflow:hidden; }
  .bar { height:100%; width:0%; background:#8aa8ff; transition: width .2s; }
  .warn { color:#b15500; }
  .ok { color:#2a8f3a; }
</style>
</head>
<body>
  <h1>排班 OCR 小工具</h1>
  <div class="row">
    <input type="file" id="files" accept="image/*" multiple />
    <button id="start" class="btn">開始辨識</button>
    <button id="clear" class="btn">清空</button>
    <button id="download" class="btn" disabled>下載 CSV</button>
  </div>

  <div class="card">
    <div class="row" id="previews"></div>
    <div class="muted">提示：可一次選多張。建議原圖清晰、不要過度壓縮。</div>
    <div style="margin-top:8px;">
      <label><input type="checkbox" id="usePre" checked /> 啟用影像前處理（灰階/對比/二值化）</label>
    </div>
  </div>

  <div class="card">
    <b>進度</b>
    <div id="overallProgress" class="progress" style="margin-top:6px;"><div class="bar" id="overallBar"></div></div>
    <div id="log" class="mono muted" style="max-height:140px; overflow:auto; margin-top:6px;"></div>
  </div>

  <div class="card">
    <b>疑似同名群組（相似度合併）</b>
    <div id="clusters" class="grid" style="margin-top:6px;"></div>
    <button id="applyMerge" class="btn" disabled>套用合併</button>
  </div>

  <div class="card">
    <b>抽取結果</b>
    <div class="muted" style="margin-bottom:6px;">欄位：日期、開始、結束、案主、來源檔名、原始片段</div>
    <div style="max-height: 300px; overflow:auto;">
      <table id="tbl">
        <thead><tr><th>日期</th><th>開始</th><th>結束</th><th>案主</th><th>來源</th><th>原始片段</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const log = (...args) => { const el = $('#log'); el.textContent += args.join(' ') + '\n'; el.scrollTop = el.scrollHeight; }

let rawTexts = [];         // [{fileName, text}]
let records = [];          // [{date, start, end, name, file, snippet}]
let nameClusters = [];     // [[{name,count}], ...]
let nameMap = {};          // mapping after merge

// ---------- 影像前處理：灰階 + 對比 + 二值化 ----------
async function preprocessImageToBlob(file, usePre=true, maxW=2000) {
  const img = document.createElement('img');
  img.src = URL.createObjectURL(file);
  await new Promise(r => img.onload = r);

  const scale = Math.min(1, maxW / img.width);
  const w = Math.round(img.width * scale);
  const h = Math.round(img.height * scale);

  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, w, h);

  if (usePre) {
    const imgData = ctx.getImageData(0,0,w,h);
    const d = imgData.data;
    // 灰階 + 對比（簡易）+ 二值化
    const contrast = 1.2; // 1~2
    const threshold = 180; // 0~255
    for (let i=0; i<d.length; i+=4) {
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      g = (g - 128) * contrast + 128;
      const v = g > threshold ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v; // 二值
    }
    ctx.putImageData(imgData,0,0);
  }

  return await new Promise(res => canvas.toBlob(b => res(b), 'image/png', 1));
}

// ---------- 文字相似度（Levenshtein） ----------
function levenshtein(a,b){
  a = a.trim(); b = b.trim();
  const m = a.length, n = b.length;
  if(!m) return n; if(!n) return m;
  const dp = Array.from({length:m+1}, (_,i)=>[i]);
  for(let j=1;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      dp[i][j] = Math.min(
        dp[i-1][j]+1,
        dp[i][j-1]+1,
        dp[i-1][j-1] + (a[i-1]===b[j-1]?0:1)
      );
    }
  }
  return dp[m][n];
}
function nameSimilarity(a,b){
  if(!a||!b) return 0;
  // 移除空白與常見噪音符號
  a=a.replace(/\s+/g,''); b=b.replace(/\s+/g,'');
  const dist = levenshtein(a,b);
  const maxLen = Math.max(a.length,b.length);
  return 1 - dist/maxLen; // 0~1
}

// ---------- 抽取邏輯（日期 / 時間 / 姓名） ----------
const dateRegex = /(\d{4})\s*年\s*(\d{1,2})\s*月\s*(\d{1,2})\s*日/g; // 2025 年 8 月 15 日
const timeRegex = /([01]?\d|2[0-3])[:：]\d{2}/g;                     // 08:30 或 8:30
const nameRegex = /([\u4e00-\u9fa5]{2,4})(?:\s|$)/;                 // 2~4 個連續中文字

function normalizeTime(t){
  return t.replace('：',':').padStart(5,'0'); // 8:30 -> 08:30
}

function extractRecordsFromText(text, fileName){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  // 找到最近的日期（每遇到日期就更新 currentDate）
  let currentDate = '';
  const out = [];

  for(let i=0;i<lines.length;i++){
    const line = lines[i];

    // 更新日期
    let m; dateRegex.lastIndex=0;
    while((m = dateRegex.exec(line))!==null){
      const y=m[1], mo=m[2].padStart(2,'0'), d=m[3].padStart(2,'0');
      currentDate = `${y}-${mo}-${d}`;
    }

    // 主策略：單行同時有「兩個時間」與「中文姓名」
    const times = (line.match(timeRegex)||[]).map(normalizeTime);
    const nameMatch = line.match(nameRegex);

    if(times.length>=2 && nameMatch){
      // 拿前兩個時間當作開始/結束
      const start = times[0], end = times[1];
      const name = nameMatch[1].replace(/\s+/g,'');
      out.push({ date: currentDate||'', start, end, name, file: fileName, snippet: line });
      continue;
    }

    // 備援 A：本行只有 1 個時間，下一行或上一行補齊
    if(times.length===1){
      const neighbor = [lines[i+1]||'', lines[i-1]||''];
      for(const nb of neighbor){
        const t2 = (nb.match(timeRegex)||[]).map(normalizeTime);
        const nm = (line+ ' ' + nb).match(nameRegex);
        if(t2.length>=1 && nm){
          const start = normalizeTime(times[0]);
          const end = t2[0];
          const name = nm[1].replace(/\s+/g,'');
          out.push({ date: currentDate||'', start, end, name, file: fileName, snippet: line + ' /// ' + nb });
          break;
        }
      }
      continue;
    }

    // 備援 B：沒有兩個時間，但看起來像一條「班 + 姓名 + 時間」的破碎線
    if(/班/.test(line) && nameMatch){
      // 盡力在鄰近行補時間
      const neighborhood = [line, lines[i+1]||'', lines[i-1]||''].join(' ');
      const tt = (neighborhood.match(timeRegex)||[]).map(normalizeTime);
      if(tt.length>=2){
        const start=tt[0], end=tt[1];
        const name = nameMatch[1].replace(/\s+/g,'');
        out.push({ date: currentDate||'', start, end, name, file: fileName, snippet: line });
      }
    }
  }
  return out;
}

// ---------- 相似姓名分群 ----------
function buildNameClusters(recs, threshold=0.85){
  const names = {};
  for(const r of recs){
    const n = r.name.trim();
    if(!n) continue;
    names[n] = (names[n]||0) + 1;
  }
  const unique = Object.entries(names).map(([name,count])=>({name,count}));
  const used = new Set();
  const clusters = [];

  for(let i=0;i<unique.length;i++){
    if(used.has(i)) continue;
    const base = unique[i];
    const group = [base];
    used.add(i);
    for(let j=i+1;j<unique.length;j++){
      if(used.has(j)) continue;
      const cand = unique[j];
      if(nameSimilarity(base.name, cand.name) >= threshold){
        group.push(cand);
        used.add(j);
      }
    }
    clusters.push(group.sort((a,b)=>b.count-a.count));
  }
  // 僅顯示有兩個以上或名稱長度>=2的（避免噪音）
  return clusters.filter(g => g.length>=2 || g[0].name.length>=2);
}

function renderClusters(){
  const wrap = $('#clusters');
  wrap.innerHTML = '';
  nameMap = {}; // reset

  nameClusters.forEach((group, idx)=>{
    const id = 'cluster_'+idx;
    const def = group[0].name; // 預設用出現最多的
    const html = `
      <div class="card">
        <div class="muted">群組 #${idx+1}</div>
        <div style="margin:6px 0;">候選：${group.map(x=>`<span class="chip">${x.name}（${x.count}）</span>`).join('')}</div>
        <label>統一為：
          <select id="${id}">
            ${group.map(x=>`<option value="${x.name}" ${x.name===def?'selected':''}>${x.name}</option>`).join('')}
          </select>
        </label>
      </div>
    `;
    const div = document.createElement('div');
    div.innerHTML = html;
    wrap.appendChild(div);
  });

  $('#applyMerge').disabled = nameClusters.length===0;
}

// ---------- 表格渲染 & 匯出 ----------
function renderTable(list){
  const tb = $('#tbl tbody');
  tb.innerHTML = '';
  for(const r of list){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${r.date||''}</td>
      <td>${r.start||''}</td>
      <td>${r.end||''}</td>
      <td>${r.name||''}</td>
      <td class="muted">${r.file||''}</td>
      <td class="muted mono">${(r.snippet||'').replaceAll('<','&lt;')}</td>
    `;
    tb.appendChild(tr);
  }
  $('#download').disabled = list.length===0;
}

function downloadCSV(list){
  const headers = ['日期','開始','結束','案主','來源檔名','原始片段'];
  const lines = [headers.join(',')];
  for(const r of list){
    const row = [r.date, r.start, r.end, r.name, r.file, r.snippet].map(v=>{
      const s = (v||'').toString().replace(/"/g,'""');
      return `"${s}"`;
    }).join(',');
    lines.push(row);
  }
  const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'shift_ocr.csv';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

// ---------- 事件綁定 ----------
$('#files').addEventListener('change', e=>{
  $('#previews').innerHTML = '';
  for (const f of e.target.files){
    const img = document.createElement('img');
    img.className = 'preview';
    img.alt = f.name;
    img.src = URL.createObjectURL(f);
    $('#previews').appendChild(img);
  }
});

$('#clear').addEventListener('click', ()=>{
  $('#files').value = '';
  $('#previews').innerHTML = '';
  $('#log').textContent = '';
  rawTexts = []; records = []; nameClusters = []; nameMap = {};
  renderClusters();
  renderTable([]);
  $('#download').disabled = true;
  $('#applyMerge').disabled = true;
  $('#overallBar').style.width = '0%';
});

$('#start').addEventListener('click', async ()=>{
  const files = $('#files').files;
  if(!files || files.length===0){ alert('請先選擇圖片'); return; }

  $('#start').disabled = true; $('#clear').disabled = true;
  $('#download').disabled = true; $('#applyMerge').disabled = true;
  $('#log').textContent = '';
  $('#overallBar').style.width = '0%';
  rawTexts = []; records = []; nameClusters = []; nameMap = {};
  renderClusters(); renderTable([]);

  log('初始化語言模型…（第一次載入較慢）');

  const worker = await Tesseract.createWorker('chi_tra+eng', 1, {
    logger: m => {
      if(m.status && typeof m.progress==='number'){
        // 單圖的內部進度就記在 log；整體進度用檔序控制
      }
    }
  });

  try{
    for(let i=0;i<files.length;i++){
      const f = files[i];
      log(`處理 ${i+1}/${files.length}：${f.name}`);
      // 前處理
      const blob = await preprocessImageToBlob(f, $('#usePre').checked);
      // OCR
      const { data: { text } } = await worker.recognize(blob);
      rawTexts.push({ fileName: f.name, text });

      // 抽取
      const recs = extractRecordsFromText(text, f.name);
      records.push(...recs);
      log(`→ 取出 ${recs.length} 筆記錄`, recs.length? '':'（可能無法解析，稍後可用原始片段檢視）');

      // 更新整體進度
      const pct = Math.round(((i+1)/files.length)*100);
      $('#overallBar').style.width = pct + '%';
    }
  } catch(err){
    console.error(err);
    log('⚠️ 發生錯誤：', err.message || err);
  } finally {
    await worker.terminate();
  }

  // 建群組 + 渲染
  nameClusters = buildNameClusters(records, 0.85);
  renderClusters();
  renderTable(records);

  $('#start').disabled = false; $('#clear').disabled = false;
  $('#applyMerge').disabled = nameClusters.length===0;
  $('#download').disabled = records.length===0;

  log('完成。你可以在上方群組選單統一名字，或直接下載 CSV。');
});

$('#applyMerge').addEventListener('click', ()=>{
  // 依使用者選擇建立 nameMap
  nameMap = {};
  nameClusters.forEach((group, idx)=>{
    const sel = $('#cluster_'+idx);
    const target = sel.value;
    for(const g of group){
      nameMap[g.name] = target;
    }
  });
  // 套用到 records
  records = records.map(r => {
    const mapped = nameMap[r.name];
    return mapped ? {...r, name: mapped} : r;
  });
  renderTable(records);
  log('已套用姓名合併。');
});

$('#download').addEventListener('click', ()=> downloadCSV(records));
</script>
</body>
</html>
